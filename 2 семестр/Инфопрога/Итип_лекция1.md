Библиотека STL - стандартная библиотека шаблонов 
cppreference - качественная вики по C++

объекты STL:
1) Контейнер
	Методы контейнеров: 
	1) size() - размер 
	2) empty() - удалить ячейку 
	3) insert() - вставить 
	4) erase() 
	5) clear() - очистить полностью 
	6) begin() - Итератор на начало
	7) end() - Итератор на конец
2) Итератор
3) Алгоритм
	Большая часть алгоритмов возвращает итератор 
4) Функциональные объекты

Контейнеры:
1) Последовательные - вставка идет последовательно
	1) array - Статический массив. Изменять размер нельзя, только менять элементы 

	2) vector - динамический массив. Длина изменяемая (но на самом деле просто выделяется память под некоторое количество элементов. Как только память заканчивается, выделяется больше памяти и он переписывается)

	3) deque - набор массивов. За константное время можно добавлять элементы в конец и начало

	4) forward-list - односвязный список. Каждый элемент содержит два поля: свой адрес, и адрес следующего за ним. Проход идет по адресам, берем адрес элемента из адреса предыдущего (кажеца). Идти по нему соответственно придется двумя указателями.

	5) list - двусвязный список. У каждого узла есть 3 значения: 2 из которых - адреса предыдущего и следующего элемента. Вставка и удаление за константное время (так как просто перестраиваются ссылки, сами элементы своих адресов не меняют (кажеца)). 
	
	Первые три - с последовательным доступом. 

2) Упорядоченные ассоциативные контейнеры - элемент встает на свое место в зависимости от определенного критерия. Результат - отсортированная последовательность 
	1) set - множество, элементы которых уникальны
	2) multiset - множество, элементы которых не уникальны
	3) map - 
	4) multimap - 

3) Неупорядоченные ассоциативные контейнеры - работают от хеш-таблицы. 
	1) unordered-set
	2) unordered-multiset
	3) unordered-map
	4) unordered-miltimap 

4) Контейнерные адаптеры - контейнеры, у которых не все контейнерные методы работают
	1) stack - очевидно лол 
	2) queue - неочевидно лол
	3) priority-queue

Итераторы: ++ - переход к следующему элементу 
	InputIterator - базовый класс. Используется для  "д а н н ы е   у д а л е н ы"
	OutputIterator - обладает функцией присвоения:   =, ++ 
	forwardIterator  - обладает функциями двух предыдущих: *, =, ++, !=, ==
	BidirectionIterator: *, =, ++, --, ==
	RandomAccessIterator: *, =, ++, --, +=, -=, <, >, <=, >=, !=, ==
1) array: RandomAccessIterator
2) vector: RandomAccessIterator
3) deque: RandomAccessIterator
4) forward-list: forwardIterator
5) list: BidirectionIterator
6) set: BidirectionIterator
7) map: BidirectionIterator
8) unordered-set: forwardIterator
9) unordered-map: forwardIterator

begin() - итератор, показывающий первый элемент списка 
end() - итератор, показывающий следующий за последним элемент

Алгоритмы
У любого алгоритма обязательными и первыми параметрами являются итераторы, показывающие промежуток действия. Для прохода по всему контейнеру используются begin() и end()
Пример:
```cpp
int k = count(a.begin(), a.end(), x);
чтобы отобрать элементы по какому-то условию можно использовать лямбда-функцию:
int k = count_if(a.begin(), a.end(), [](int x){return x%2==0;});
```

Чтобы использовать несколько параметров в лямбда-функции (глобальные например)
```c++
int c,d;
cin >> c >> d;
int k = count_if(a.begin(), a.end(), [&c, &d](int x){return x>=c && x<=d;});
```
Функция remove. Ненужные элементы перетаскивает в конец. После этого их нужно будет стереть 

```cpp
auto it = remove(a.begin(), a,end(), max);
a.erase(it, a.end());
```

библиотека numeric 
Что нам там нужно? accumulate (суммирует контейнер), inner_product, partial_sum
